%% Run forecast scenarios


%% Clear workspace

close all
clear



%% Load models and data

load mat/readModel.mat m mx
load mat/dates.mat startHist endHist startFcast endFcast
h = databank.fromCSV("csv/initial-conditions.csv");

endExternals = getEnd(h.dl_cpif);
startChart = startFcast - 5*4;


%% Hands-free

f0 = simulate( ...
    m, h, startFcast:endFcast ...
    , "prependInput", true ...
);

fx0 = simulate( ...
    mx, h, startFcast:endFcast ...
    , "prependInput", true ...
    , "method", "stacked" ...
    , "solver", "quickNewton" ...    
);


h.i(startFcast+1:endFcast) = h.i(startFcast);



%% Add trend and external projections

p1 = Plan.forModel(m, startFcast:endFcast);
p1 = swap( ...
    p1, startFcast:endFcast ...
    , ["dl_y_tnd", "shock_g_y_tnd"] ...
    , ["r_tnd", "shock_r_tnd"] ...
    , ["dl_z_tnd", "shock_dl_z_tnd"] ...
    , ["rf_tnd", "shock_rf_tnd"] ...
);

p1 = swap( ...
    p1, startFcast:endExternals ...
    , ["dl_cpif", "shock_dl_cpif"] ...
    , ["if", "shock_if"] ...
    , ["l_yf_gap", "shock_l_yf_gap"] ...
    ... , ["l_rp_oil_gap", "shock_l_rp_oil_gap"] ...
);


f1 = simulate( ...
    m, h, startFcast:endFcast ...
    , "prependInput", true ...
    , "plan", p1 ...
);



%{
px1 = Plan.forModel(mx, startFcast:endFcast);
px1 = swap( ...
    px1, startFcast:endFcast ...
    , ["dl_y_tnd", "shock_g_y_tnd"] ...
    , ["r_tnd", "shock_r_tnd"] ...
    , ["dl_z_tnd", "shock_dl_z_tnd"] ...
    , ["rf_tnd", "shock_rf_tnd"] ...
);

px1 = swap( ...
    px1, startFcast:endExternals ...
    , ["dl_cpif", "shock_dl_cpif"] ...
    , ["if", "shock_if"] ...
    , ["l_yf_gap", "shock_l_yf_gap"] ...
    ... , ["l_rp_oil_gap", "shock_l_rp_oil_gap"] ...
);


fx1 = simulate( ...
    mx, h, startFcast:endFcast ...
    , "prependInput", true ...
    , "plan", px1 ...
    , "method", "stacked" ...
    , "solver", "quickNewton" ...
);
%}


%% Added NTF

p2 = p1;

p2 = swap( ...
    p2, startFcast:startFcast+3 ...
    , ["dl_cpi_core", "shock_dl_cpi_core"] ...
    , ["dl_cpi_ncore", "shock_dl_cpi_ncore"] ...
);

p2 = swap( ...
    p2, startFcast:startFcast+1 ...
    , ["l_y_gap", "shock_l_y_gap"] ...
);

p2 = swap( ...
    p2, startFcast:startFcast ...
    , ["l_s", "shock_l_s"] ...
);


p2 = swap( ...
    p2, startFcast:startFcast ...
    , ["i", "shock_i"] ...
);


f2 = simulate( ...
    m, h, startFcast:endFcast ...
    , "prependInput", true ...
    , "plan", p2 ...
);


%{
px2 = px1;

px2 = swap( ...
    px2, startFcast:startFcast+2 ...
    , ["dl_cpi_core", "shock_dl_cpi_core"] ...
    , ["dl_cpi_ncore", "shock_dl_cpi_ncore"] ...
);

px2 = swap( ...
    px2, startFcast:startFcast+1 ...
    , ["l_y_gap", "shock_l_y_gap"] ...
);

px2 = swap( ...
    px2, startFcast:startFcast ...
    , ["l_s", "shock_l_s"] ...
);


px2 = swap( ...
    px2, startFcast:startFcast ...
    , ["i", "shock_i"] ...
);


fx2 = simulate( ...
    mx, h, startFcast:endFcast ...
    , "prependInput", true ...
    , "plan", px2 ...
    , "method", "stacked" ...
    , "solver", "quickNewton" ...    
);

%% Report credit extension

ch = databank.Chartpack();
ch.Range = startHist:endFcast;
ch.Round = 8;
ch.Highlight = startHist:endHist;

ch < ["l_y_gap", "dl_cpi", "dl_py", "dl_ny"];
ch < ["dl_bc", "[bc_to_ny, bc_to_ny_tnd]", "bc_new_to_ny"];
ch < ["cc_gap"];

draw(ch, fx2);

%}


%% Add government guarantees for private credit 
%
% Future demand pressures are assumed to be already incorporated in NTF
%

startGuar = qq(2022,3);
endGuar = qq(2023,1);

h3 = f2;
p3 = p2;

p3 = swap(p3, startGuar:endGuar, ["l_y_gap", "shock1_l_y_gap"]);

h3.l_y_gap(startGuar:endGuar) = f2.l_y_gap(startGuar:endGuar) + [1; 1.5; 1.4];

f3 = simulate( ...
    m, h3, startFcast:endFcast ...
    , "prependInput", true ...
    , "plan", p3 ...
);


%% Add government guarantees for private credit 
%
% Future demand pressures are not part of the NTF, allow the variables to
% react on this extra information endogenously
%

% Run auxiliary simulation

d = steadydb(m, startFcast:endFcast);
d.l_y_gap(startGuar:endGuar) = [1; 1.5; 1.4];
q = Plan.forModel(m, startFcast:endFcast);
q = swap(q, startGuar:endGuar, ["l_y_gap", "shock_l_y_gap"]);
guar = simulate( ...
    m, d, startFcast:endFcast ...
    , "plan", q ...
);


% d1 = steadydb(m, startFcast:endFcast);
% d1.shock_l_y_gap(startGuar:endGuar) = s.shock_l_y_gap(startGuar:endGuar);
% s1 = simulate(m, d1, startFcast:endFcast);


h4 = f2;

h4.shock1_l_y_gap(startGuar:endGuar) = ...
    h4.shock1_l_y_gap(startGuar:endGuar) ...
    + guar.shock_l_y_gap(startGuar:endGuar);

f4 = simulate( ...
    m, h4, startFcast:endFcast ...
    , "prependInput", true ...
);


%% Keep interest rates unchanged for T quarters

T = 4;
h5 = f4;
p5 = Plan.forModel(m, startFcast:endFcast);
p5 = swap(p5, startFcast:startFcast+T, ["i", "shock_i"]);
h5.i(startFcast:startFcast+T) = h5.i(startFcast);

f5 = simulate( ...
    m, h5, startFcast:endFcast ...
    , "prependInput", true ...
    , "plan", p5 ...
);


% %% Unchanged policy
% %
% % Take baseline, keep interest rate unchanged, and find Phillips curve
% % shocks consistent with unchanged policy rates
% 
% h6 = f2;
% 
% m.std_shock1_dl_cpi_core = 0;
% m.std_shock1_l_y_gap = 1;
% 
% p6 = Plan.forModel(m, startFcast:endFcast, "method", "condition");
% p6 = exogenize(p6, startFcast:startFcast+2, "i");
% p6 = endogenize(p6, startFcast:startFcast+2, ["shock1_dl_cpi_core", "shock1_l_y_gap"]);
% 
% h6.i(startFcast:startFcast+2) = h6.i(startFcast);
% 
% 
% f6 = simulate( ...
%     m, h6, startFcast:endFcast ...
%     , "prependInput", true ...
%     , "plan", p6 ...
% );


%% Add government guarantees for private credit as alternative scenario
%
%



p7 = Plan.forModel(m, startGuar:endFcast);
p7 = swap(p7, startGuar:endGuar, ["l_y_gap", "shock_l_y_gap"]);

h7 = f2;
h7.l_y_gap(startGuar:endGuar) = [1; 1.5; 1.4];

f7 = simulate( ...
    m, h7, startGuar:endFcast ...
    , "prependInput", true ...
    , "plan", p7 ...
);


%%


% p3 = p2;
% p3 = swap( ...
%     p3, startFcast:startFcast+10 ...
%     , ["i", "shock_i"] ...
% );
% 
% 
% f3 = simulate( ...
%     m, h, startFcast:endFcast ...
%     , "prependInput", true ...
%     , "plan", p3 ...
% );

%f2.shock_l_y_gap(startFcast+2) = -10i;
%s2 = simulate(m, f2, startFcast:endFcast);







%% Chart forecast scenarios


ch = databank.Chartpack();
ch.Range = startChart:endFcast;
ch.Highlight = startChart:endHist;

ch < ["i", "dl_cpi", "dl_cpi_core", "dl_cpi_ncore", "l_y_gap", "exp(l_s/100)"];
%ch < ["shock_dl_cpi_core", "shock1_dl_cpi_core", "shock1_l_y_gap"];
% draw(ch, databank.merge("horzcat", f2, f3, f4, f5));
% draw(ch, databank.merge("horzcat", f4));

clear(ch);
% ch < ["if", "dl_cpif", "l_yf_gap", "l_rp_oil_gap"];
ch < ["dl_y_tnd", "r_tnd", "l_z_tnd", "rf_tnd"];

% draw(ch, databank.merge("horzcat", f4));

% legend( ...
%     "Baseline w/ NTF" ...
%     , "Credit guarantees assumed in NTF" ...
%     , "Credit guarantees not in NTF" ...
%     , "Credit guarantees as alternative scenario" ...
% );


%% Save baseline to CSV

databank.toCSV( ...
    f3, "csv/baseline-forecast-2021Q3.csv", startHist:endFcast ...
    , "decimals", 16 ...
);






